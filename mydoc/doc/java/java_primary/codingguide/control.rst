控制语句写法
==========================

在一个switch内，每个case要么使用break / return来终止，要么注释说明程序将继续执行到具体的哪个case为止；在一个switch内必须包含default代码块在所有case之后，就算业务逻辑为空也要存在！

在if / else / for / while / do语句中必须使用大括号，即便是只有一行代码，也需要添加大括号。

.. code:: java

    if (condition) {
        statements;
    }

在表达异常分支时，尽可能的少用if / else if嵌套方式，可以修改成：

.. code:: java

    if (condition) {
        //...
        return object;
    }
    // 继续处理 else / else if 业务逻辑代码


如果不得不使用超过三层的if / else if逻辑判断，可以将代码改成卫语句、策略设计模式、状态设计模式，下面是卫语句示例：

.. code:: java


        public void today () {
            if (isBuy()) {
                System.out.println("do something.");
                return;
            }
            if (isFree()) {
                System.out.println("do something.");
                return;
            }
            System.out.println("coding..");
        }


在我们系统设计时，一般都会使用throw new XxxException();将return;代替，所有逻辑异常判断都采用自定义业务逻辑异常进行处理。



**【强制】** 在高并发场景中，避免使用 ”等于”
判断作为中断或退出的条件。

说明：如果并发控制没有处理好，容易产生等值判断被“击穿”
的情况，使用大于或小于的区间判断条件来代替。

反例：
判断剩余奖品数量等于0
时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变
成了负数，这样的话，活动无法终止。

**【推荐】** 除常用方法（如
getXxx/isXxx
）等外，不要在条件判断中执行
其它
复杂的语句，将
复杂逻辑判断的结果赋值给一个有意义的布尔变量
名
，以提高可读性。

说明：
很多
if
语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么
样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？

::

    正例：
    // 伪代码如下
    final boolean existed = (file.open(fileName, "w") != null) &&(...) || (...);
    if (existed) {
    ...
    }  

    反例：
    if ((file.open(fileName, "w") != null) &&(...) || (...)) {
    ...
    }


**【推荐】** 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、
获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）
。


**【推荐】** 避免采用取反逻辑运算符。

说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。

正例：使用 if (x < 628) 来表达 x 小于 628。

反例：使用 if (!(x >= 628)) 来表达 x 小于 628。

**【推荐】** 接口入参保护，这种场景常见的是用作批量操作的接口。

**【参考】** 下列情形，需要进行参数校验：

::

    1） 调用频次低的方法。
    2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参
    数错误导致中间执行回退，或者错误，那得不偿失。
    3） 需要极高稳定性和可用性的方法。
    4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。
    5） 敏感权限入口。



**【参考】** 下列情形，不需要进行参数校验：

::

    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。
    2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底
        层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所
        以 DAO 的参数校验，可以省略。
    3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参
        数已经做过检查或者肯定不会有问题，此时可以不校验参数。

**【参考】** 下列情形，需要进行参数校验：

::

    1） 调用频次低的方法。
    2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参
    数错误导致中间执行回退，或者错误，那得不偿失。
    3） 需要极高稳定性和可用性的方法。
    4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。
    5） 敏感权限入口。



**【参考】**  下列情形，不需要进行参数校验：

::

    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。
    2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底
    层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所
    以 DAO 的参数校验，可以省略。
    3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参
    数已经做过检查或者肯定不会有问题，此时可以不校验参数。