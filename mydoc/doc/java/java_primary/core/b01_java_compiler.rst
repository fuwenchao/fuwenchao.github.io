谈谈你对java体系的理解，“java是解释执行”这句话对吗
============================================================


java 是解释执行，这句话不太准确

**常见**

    java源代码 ---> 编译时 javac 字节码 .class ---> 运行时 JVM 内嵌解释器将字节码转换成 机器码 （一次编译，到处运行）


**但是**

大多数JVM提供了JIT（just in time）编译器，也就是动态编译器，JIT在运行时将 **热点代码** 编译
成 **机器码** ，这种情况下这部分热点代码就属于 **编译执行** ,而不是 **解释执行** 了


**运行时**

JVM通过类加载器（class-loader)加载字节码，解释或者编译执行。主流java版本中，
如JDK8，实际是解释和编译混合的一种模式，即所谓的 **混合模式** （-Xmixed)。

通常运行在server模式的JVM，会进行上万次调用以收集足够的信息进行高效编译，
client 这个门限是1500。

Oracle Hotspot JVM 内置了两种不同的 JIT compiler，C1对应前面说的 **client** ，适合启动速度敏感的应用，如桌面端应用；
C2对应 **server** 模式，他的优化是为长时间运行的服务器端应用设计。

默认采用分层编译（TieredCompilation）。具体后面再讲

JVM启动时，可以指定不同的参数对运行模式进行选择，比如

- **"-Xint"** 就是告诉JVM只进行解释执行，不对代码进行编译，这种模式抛弃了JIT可能带来的性能优势。毕竟解释器是逐条读入解释运行的。
- **"-Xcomp"** 告诉JVM关闭解释器，不要进行解释执行，或者叫做最大级别优化，那么这种模式是不是最高效的呀？未必。
    该参数会导致JVM启动变慢非常多，同时有些JIT编译器的优化方式，比如分支预测，如果不进行profiling，旺旺往往并不能进行有效优化

除了我们常见的Java使用模式，还有一种新的编译方式，AOT（ahead of time compilation）,直接将字节码编译成机器代码，这样就避免了JIT预热等各方面的开销。详略




